<center><h1> Amazon-FreeRTOS 可行性报告 </h1></center>

<center><b>作者：邓浩巍，方宇辰，王梓涵，朱河勤（字典序）</b></center>


# 能力分析

## 程序语言
我们决定用 C 语言完成我们的项目代码部分。一个原因是现有的嵌入式系统大多是 c 语言实现的，有很多资料，经验可以学习，借鉴。

另外，C 语言有很多优点，比如：简洁紧凑、速度极快，是一门结构式语言，还可以允许直接访问物理地址，可以直接对硬件进行操作
因此既具有高级语言的功能，又具有低级语言的许多功能，能够象汇编语言一样对位、字节和地址进行操作，非常适合写系统软件。
C 语言有一个突出的优点就是适合于多种操作系统，如 DOS、UNIX, 也适用于多种机型。

加之我们都学习过 C 语言，都还算熟悉。可以灵活运用。
### 看过一些提高的教程，如
* `<<c 与指针》>`
* `<<c 专家编程》>`
* `<<accelerate c++>>`
* ...
### 练习过很多项目
* `huffman 压缩解压缩`
* `模拟银行`
* `路径搜索`
* ...

我们组的成员都能用 c 语言写出一些项目，不像其他组用 rust, 要花额外的时间来学习。
这样我们就能将精力放在优化，提高 Amazon-FreeRTOS 在微控制器上的性能，作出更多的创新性工作。

## 资料
关于嵌入式操作系统的资料比较多，虽然有质量的论文，资料是英文的，但是我们组的一些同学英语水平较高，读英文 paper 的能力较强。

Amazon-FreeRTOS 还有专门的用户手册，开发指南等等。更进一步的，Amazon-FreeRTOS 是开源的，我们可以得到它的源码。

这些都可以让我们快速地学习 free-RTOS,  掌握一个嵌入式系统的知识与构建过程，逐步改进，完善嵌入式操作系统 free-RTOS 的功能。

## 算法与数据结构

我们小组的成员都上过数据结构课，并且课外还练习过其他算法，如各种排序算法，实现过其他高级数据结构，比如 splay tree, trie 等，
所以实现，改进，创新性地颠覆一个在某些领域更合适的算法或者是数据结构是一件可以期望的事。经过我们长时间，认真的调研，
我们初步发现了 Amazon-FreeRTOS 的一些地方，尤其是内存管理，资源调度方面是值得改进的，这也是我们项目的重点。我们有能力做出进一步的工作与成果。


# 项目分析
## 项目定位
Amazon FreeRTOS 还存在需要优化的地方，我们的项目工作主要放在功耗、内存、连接性、安全性等方面。
并在某个特定的领域 -- 微型控制器上做出相应的优化工作。

>这是实用的。

目前有很多微小的设备都需要微型控制器实现精确控制，

>这是可行的

Amazon-FreeRTOS 源代码相对较少，内核精简，对于我们来说，有时间，有精力，有能力完成。

## 实现内容
 我们目前已经熟悉了 Amazon-FreeRTOS 的内存调度算法，发现简单的算法无法达到要求，能达到要求的算法较为复杂，在硬件上实现颇有难度。
 我们小组经过多次讨论与探究，决定精简一部分，实现在某些领域更实用，可靠的 Amazon-FreeRTOS 版本。
 
 ### FreeRTOS内存管理优化的可行性分析
理论依据<br>
FreeRTOS现有的内存管理策略主要有一下问题：<br>
	>时间确定性不强
对于已有的heap_1至heap_5五种策略，只有heap_1能在O(1)时间内完成内存分配工作，但是heap_1没有释放功能。对于heap_2至heap_5，由于没有索引，只有一个简单的链表管理未分配空间，每当应用请求空间时都需要顺序查找链表，无法做到固定时间的存取，不利于系统的实时性。
	对于碎片的处理不够有效
目前只有heap_4与heap_5有针对碎片进行的处理，所进行的操作仅仅是把相邻的空闲块合并。在小内存设备中对碎片的可以进一步优化。
针对以上问题，在新算法TLSF中，采取位图与链表相结合的方式对内存池进行管理，结合了两者的有点，即速度快、碎片少。
TLSF算法使用隔离适应机制实现了一个最佳适应策略，原算法针对4G内存设计，即32位地址。为了加速访问空闲块同时管理一大组隔离链表，链表数组被分为两级管理。第一级将空闲内存块划分为若干个个区间，称为FLI（First-level Segregated Fit）。第二级别SLI（Second-level Segregated Fit）把第一级线性划分为2SLI个区间（SLI是一个用户可配置参数）。两个级别各对应一个位图，用来标记对应内存是否为空，如果不空则有一个指针指向内存块，否则为空。
为了更快地合并空闲块，TLSF算法在每个内存块前面添加一小块“内存块报头”(block header)。对于空闲块，报头中含有块大小、物理上的前一块地址、前一个和后一个空闲块地址；对于已使用块，报头中含有块大小、物理上的前一块地址。因此每个空闲内存块被两个链表连接：1)隔离链表：对应SLI，将同一类的内存块连接起来和2)由物理地址排序的链表。这样只要给出某一内存块在第一、二级中的位置，通过连续两个指针可以直接访问到对应报头得到所有信息，如下图1所示。
为了实现O(1)时间的内存分配和回收，TLSF使用segregate list()函数确定需求内存块位置。在第一级FLI中，内存区间按2的次幂排序，因此若用mapping (size) → (f, s)表示对应块在第一、二级数组中的位置，f =⌊log_2  (size)⌋  ，s=(size-2^f)2^SLI/2^f 。
如果用上式找到了空闲内存，则返回，若无法找到，则找下一个比需求大的内存块。此操作由于采用位图搜索算法时间复杂度也为O(1)。
释放内存的方式和上述过程基本相同，先计算f与s，然后利用报头中的信息合并相邻空闲空间。

>技术依据
针对FreeRTOS的64KB的内存，需要对TLSF算法做一定的改进。具体来说，对于报头，64K内存只有16位地址，因此报头中每个数据都为16位。另外，由于数据通常以4B为单位(word)，大小数据实际上只需要14位，余下两位作为标志位，分别标记是否为空闲块和是否为物理上的最后一块，如下图。
根据TLSF算法，可以简单写出malloc时的伪代码如下。

     void *malloc(size){
	int fl, sl, fl2, sl2;
	void *found_block, *remaining_block;
	mapping (size, &fl, &sl); 	// O(1)，计算f与s
	found_block=search_suitable_block(size,fl,sl);// O(1)，根据f,s搜索合适块
	remove (found_block); 	// O(1)，从链表移除即将分配的块
	if (sizeof(found_block)>size) {	//如果大小不是完全相等
		remaining_block = split (found_block, size);	//将当前块分成两块
		mapping (sizeof(remaining_block),&fl2,&sl2);	//计算未使用块的f与s
		insert (remaining_block, fl2, sl2); 	// O(1)，根据f,s将剩余块加入链表
	}
	return found_block;
    }

free函数伪代码如下。

     void free(block){
	    int fl, sl;
	    void *big_free_block;
	    big_free_block = merge(block); // O(1)，块合并
	    mapping (sizeof(big_free_block), &fl, &sl);
	    insert (big_free_block, fl, sl); // O(1)
     }
对于具体变量的数据类型，可以根据FreeRTOS内核的定义进行适当的修改。FreeRTOS的数据类型更为细致，可以使用16位变量保存块报头的数据，s与l可以使用8位变量，压缩花费空间。
以64K存储为例，存储二维数组及位图需要不到100B的空间，对于每一个内存块，报头需要占用8B。这对于需要多次申请小空间的应用来说显然开销很大，但是对于稍大的内存申请来说可以接受。另外由于有合并策略，多个连续小内存块的报头在多次释放后不会一直存在，不会造成浪费。
针对TLSF算法，已经有多个实验。TLSF在面对First-Fit, Best-Fit, Douglas Lea’s malloc,
Binary Buddy四个算法的效果表1。[2]
其中加粗项为针对对应算法的最坏情况，表中数据单位为时钟周期。从数据可见TLSF算法相比于其他算法稳定性极强，对于各种情况所花费时间最为稳定。

创新点
相比于现有策略，新算法可以明显FreeRTOS的实时性，并把额外内存消耗控制在可以接受的范围之内。
对于碎片有一定的优化。


